
#include <iostream>
#include <vector>
#include <unordered_map>
#include <map>



using namespace std;

class my_hash1 {
public:
	int operator()(const vector < vector<int>>& M) const {//the last const is necessary
		int sum = 0;
		for (auto i : M)
			for (auto j : i) sum += j;
		hash<int> h;
		return h(sum * sum + sum);
	}
};

class my_equal_to1 {
public:
	bool operator()(const vector<vector<int>>& M1, const vector<vector<int>>& M2) const { //the last const is necessary
		int sum1 = 0;
		for (auto i : M1)
			for (auto j : i) sum1 += j;
		int sum2 = 0;
		for (auto i : M2)
			for (auto j : i) sum2 += j;

		size_t s1{ M1.size() }, s2, s3{ M2.size() }, s4;
		s2 = M1[0].size();
		s4 = M2[0].size();
		return (sum1 == sum2 && s1 == s3 && s2 == s4);
	}

};

ostream& operator << (ostream& str, const vector<vector<int>>& M) {
	str << endl;
	for (auto i : M) {
		for (auto j : i) {
			str << j << " ";
		}
		str << endl;
	}
	return str;
}


class myCompare1 {
public:
	bool operator()(const list<int*>* p1, const list<int*>* p2) const {
		int sum1{ 0 }, sum2{ 0 };
		for (auto i : *p1) {
				sum1 += *i;
		}
		for (auto i : *p2) {
			sum2 += *i;
		}
		return sum1 < sum2;
	}
};

class my_hash2 {
public:
	size_t operator()(const map<list<int*>*, vector<int*>, myCompare1>& M) const {
		int sum{ 0 };
		for (auto i : M) {
			for (auto j : *(i.first)) {
				sum += *j;
			}
			for (auto j : i.second) {
				sum += *j;
			}
		}
		hash<int> h;
		return h(sum);
	}
};

class my_equal_to2 {
public:
	bool operator()  (const map<list<int*>*, vector<int*>, myCompare1> &M1, const map<list<int*>*, vector<int*>, myCompare1> & M2)  const {
		
		int sum1{ 0 }, sum2{ 0 };
		for (auto i : M1) {
			for (auto j : *(i.first)) {
				sum1 += *j;
			}
			for (auto j : i.second) {
				sum1 += *j;
			}
		}
		for (auto i : M2) {
			for (auto j : *(i.first)) {
				sum2 += *j;
			}
			for (auto j : i.second) {
				sum2 += *j;
			}
		}

		return sum1 == sum2;

	}

};

ostream& operator<<(ostream& str, const
	unordered_map<map<list<int*>*, vector<int*>, myCompare1>, int, my_hash2, my_equal_to2>& HT2)
{
	str << "{ ";
	for (auto i : HT2) {
		str << "[ ";
		for (auto j : i.first) {
			str << "< ";
			for (auto k : *(j.first)) {
				str << *k << " ";
			}
			str << "> ";
			str << "( ";
			for (auto k : j.second) {
				str << *k << " ";
			}
			str << ") ";
		}
		str << "] ";

		str << " "<< i.second << " ";

	}
	cout << " }";
	return str;
}


ostream& operator<<(ostream & str, const unordered_map<vector<vector<int>>, int, my_hash1, my_equal_to1>& HT) {
	for (auto i : HT) {
		for (auto j : i.first) {
			for (auto k : j) {
				str << k << " ";
			}
			str << endl;
		}
		str << i.second << endl;
	}
	return str;
}

ostream& operator<<(ostream& str, const pair<vector<vector<int>>, int>& P) {
	for (auto i : P.first) {
		for (auto j : i) {
			str << j << " ";
		}
		str << endl;
	}
	str << P.second;
	return str;
}


ostream& operator<<(ostream & str, const pair<map<list<int*>*, vector<int*>, myCompare1>, int> &P) {
	str << "[ ";
	for (auto i : P.first) {
		str << "< ";
		for (auto j : *(i.first)) {
			str << *j << " ";
		}
		str << "> ";
		str << "( ";
		for (auto j : i.second) {
			str << *j << " ";
		}
		str << ") ";
	}
	str << "] ";
	str << " "<<P.second;

	return str;
}


int main() {
	int n;
	cin >> n;
	vector<vector<vector<int>>> M(n);
	for (int i = 0; i < n; i++) {
		int r{ rand() % 31 + 10 }, c{ rand() % 31 + 10 };
		vector<int> v(c);
		M[i].resize(r, v);
	}
	for (int k = 0; k < n; k++) {
		for (auto& i : M[k]) {
			for (auto& j : i) {
				j = rand() % 100;
			}
		}
	}


	unordered_map<vector<vector<int>>, int, my_hash1, my_equal_to1> HT1;
	for (int i = 0; i < n; i++) {
		HT1.insert({ M[i], 1+rand()%n });
	}
	cout << HT1 << endl;

	auto it = HT1.find(M[n-1]);
	if (it != HT1.end()) {
		cout << *it << endl;
	}

	unordered_map<map<list<int*>*, vector<int*>, myCompare1>, int, my_hash2, my_equal_to2> HT2;
	//myCompare1 will compare the sums of all ints in keys
	//my_hash2 will be h(sums of all ints)
	//my_equal_to2 will be equal in sums of keys

	map<list<int*>*, vector<int*>, myCompare1>
		m1{ {
				{ new list<int*>{new int{10}, new int{20}, new int{30} }   , {new int{20}, new int{40}}   },
				{ new list<int*>{new int{40}, new int{20}, new int{30} }   , {new int{20}, new int{40}, new int{100}}   }
			} },
		m2{ {
				{ new list<int*>{new int{10}, new int{20}, new int{30} }   , {new int{20}, new int{40}}   },
				{ new list<int*>{new int{40}, new int{20}, new int{30} }   , {new int{20}, new int{40}, new int{200}}   }
			} };
	//Overload opeator<< such that the following cout statement will work.


	HT2.insert({ m1, 1 });
	HT2.insert({ m2, 2 });

	cout << HT2 << endl;
	auto it2 = HT2.find(m1);
	if (it2 != HT2.end())  cout << *it2 << endl;
	

	return 0;
}