

//Shallow and Deep copy and assignment
//copy constructor, destructor, operator assignment (or operator=)
#include <iostream>
#include <string>

using namespace std;

class Node {
public:
	int value;
	Node* next;
	Node() { next = nullptr; }
	Node(int i) { value = i; next = nullptr; }
};

class LinkedList {
public:
	Node* head;
	LinkedList() { head = nullptr; }
	LinkedList(const initializer_list<int>& I);
	LinkedList(const LinkedList& L);//copy constructor
	/*
	In three cases, copy constructor will be called:
	(1) When an object is declared and in the same statement initialized to another object
	(2) pass by value
	(3) return by value

	*/


	void operator=(const LinkedList& L);//overloaded operator=
	LinkedList ThreeTimes();//Value of every node is three times of the current LinkedList
	~LinkedList();//destructor
	/*
	In two cases destructor will be called:
	(1) When an object goes out of scope
	(2) Node * p = new LinkedList();
	....

	delete p;
	*/

	LinkedList(LinkedList&& L);//Move constructor -- R value version of copy constructor
	void operator=(LinkedList&& L); //R-value version of operator=



};

void LinkedList::operator=(LinkedList&& L) {
	while (head) {
		Node* p = head->next;
		delete head;
		head = p;
	}
	head = L.head;
	L.head = nullptr;
	cout << "R-value operator=" << endl;
}


LinkedList::LinkedList(LinkedList&& L) {
	head = L.head;
	L.head = nullptr;
	cout << "Move constructor" << endl;
}

LinkedList::~LinkedList() {
	while (head) {
		Node* p = head->next;
		delete head;
		head = p;
	}
	cout << "Destructor" << endl;
}


LinkedList LinkedList::ThreeTimes() {
	LinkedList temp(*this);
	Node* p = temp.head;
	while (p) { p->value *= 3; p = p->next; }
	return temp;
	//compiler will automatically change it into "return move(temp);"
	//move(i) will change i into R value
}


void LinkedList::operator=(const LinkedList& L) {
	while (head) {
		Node* p = head->next;
		delete head;
		head = p;
	}
	Node* p1 = L.head;
	while (p1) {
		Node* p = new Node();
		p->next = head;
		head = p;
		p1 = p1->next;
	}
	p1 = head;
	Node* p2 = L.head;
	while (p1) {
		p1->value = p2->value;
		p1 = p1->next;
		p2 = p2->next;
	}

	cout << "L value Operator=" << endl;
}


LinkedList::LinkedList(const LinkedList& L) : LinkedList() {
	Node* p1 = L.head;
	while (p1) {
		Node* p = new Node();
		p->next = head;
		head = p;
		p1 = p1->next;
	}
	p1 = head;
	Node* p2 = L.head;
	while (p1) {
		p1->value = p2->value;
		p1 = p1->next;
		p2 = p2->next;
	}
	cout << "Copy Constructor" << endl;
}
LinkedList::LinkedList(const initializer_list<int>& I) {
	head = nullptr;
	auto it = I.end() - 1;
	while (it != I.begin() - 1) {
		Node* p = new Node(*it);
		p->next = head;
		head = p;
		it--;
	}
	cout << "Initializer_list" << endl;
}

ostream& operator<<(ostream& str, const LinkedList& L) {
	Node* p = L.head;
	while (p) { str << p->value << " "; p = p->next; }
	return str;
}

int main() {
	LinkedList L1{ 3,6,9,12,15 };
	cout << L1 << endl;
	LinkedList L2{ L1 };//will call default copy constructor
	//You can also write it as
	//LinkedList L2 = L1; //call copy constructor
	L2.head->value = 100;
	cout << L1 << endl;
	LinkedList L3;
	L3 = L1; //call operator=
	L3.head->value = 200;
	cout << L1 << endl;
	LinkedList L4;
	L4 = L1.ThreeTimes();
	//L4.operator=(L1.ThreeTimes());
	cout << L4 << endl;
	return 0;
}


