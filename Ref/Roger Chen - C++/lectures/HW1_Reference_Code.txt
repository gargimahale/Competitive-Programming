//HW1: Due 11 : 59pm, Monday, Janray 27.
//Implement the three member functions new_reverse, new_sort and removeAll.

//Linked List Operations
#include <iostream>//cin and cout
using namespace std;
class Node {
public:
	int value;
	Node* next;
	Node() { next = nullptr; }//default constructor
	Node(int i) { value = i; next = nullptr; }//constructor

};

class LinkedList {
public:
	Node* head;
	LinkedList() { head = nullptr; }
	void makeList(int m, int n);//create a linked list of m nodes with 
	//values randomly distrubuted in 0..n-1
	void printList();
	void new_reverse(); //You are only allowed to modify "values" of nodes, but not "next"
	//You have to directly work on the linked list.  You are not allowed to use
	//external structures such as array or linked list to perform operations.

	void new_sort();//Sorting -- Only modify pointers (next or temporary pointers).
	//Changes of values of nodes are not allowed.
	//You are not allowed to use external structures such as array or linked list
	//to perform operations and transfer the values back to the linked list.

	void removeAll(int k);//Remove all nodes with value k
};
void LinkedList::makeList(int m, int n) {
	for (int i = 0; i < m; i++) {
		Node* p = new Node(rand() % n);
		p->next = head;
		head = p;
	}
}

void LinkedList::printList() {
	Node* p = head;
	cout << endl;
	while (p) { cout << p->value << " ";  p = p->next; }
}

void LinkedList::new_reverse() {
	//You need to implement this function.
	if (!head || !head->next) return;
	Node* p1 = head, * p2 = nullptr;
	while (!(p1 == p2 || p1->next == p2)) {
		Node* p3 = p1->next;
		while (p3->next != p2) p3 = p3->next;
		int temp = p3->value;
		p3->value = p1->value;
		p1->value = temp;
		p1 = p1->next;
		p2 = p3;
	}
}
void LinkedList::new_sort() { //selection sort
//You need to implement this function.
	if (!head || !head->next) return;//if 0 or 1 node, return;
	Node* p1 = head, * p2, * p1_previous{ head }, * p2_previous{ head }, * p_min_previous{ head };
	int min;
	Node* p_min;
	while (p1) {
		min = p1->value;
		p_min = p1;
		p2 = p1->next;
		while (p2) {
			if (p2->value < min) {
				min = p2->value;
				p_min = p2;
				p_min_previous = p2_previous;
			}
			p2_previous = p2;
			p2 = p2->next;
		}
		if (p1 != p_min) {
			if (p1->next == p_min) {
				p1->next = p_min->next;
				p_min->next = p1;
				if (head == p1) {
					head = p_min;
				}
				else {
					p1_previous->next = p_min;
				}
			}
			else {//p1->next != p_min
				Node* p3 = p1->next;
				p1->next = p_min->next;
				p_min_previous->next = p1;
				p_min->next = p3;
				if (head == p1) {
					head = p_min;
				}
				else {
					p1_previous->next = p_min;
				}
			}
		}
		p1_previous = p_min;
		p1 = p_min->next;
	}
}

void LinkedList::removeAll(int k) {
	if (!head) return;
	while (head->value == k) {
		Node* p1 = head->next;
		delete head;
		head = p1;
	}
	Node* p1 = head;
	if (!p1 || !p1->next) return;

	Node* p2 = p1->next;
	while (p2) {
		if (p2->value == k) {
			p1->next = p2->next;
			delete p2;
			p2 = p1->next;
		}
		else {
			p1 = p2;
			p2 = p2->next;
		}
	}
}

//Different test cases will be used during grading
//Need to pay special attention to bounary cases
int main() {
	LinkedList L1, L2;
	L1.makeList(11, 60);
	L1.printList();
	L1.new_reverse();
	L1.printList();
	L1.new_sort();
	L1.printList();
	L2.makeList(30, 20);
	L2.printList();
	L2.removeAll(15);
	L2.printList();
	return 0;
}


