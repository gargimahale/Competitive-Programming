//map and unordered_map (for hash table)
#include <iostream>
#include <map>
#include <unordered_map>
#include <string>
#include <vector>
#include <algorithm> //for_each
#include <stack>
using namespace std;
template <typename T> struct ThreeD {
	T ht;
	T wid;
	T dep;
	ThreeD() { ht = wid = dep = 0; }
	ThreeD(T i, T j, T k) { ht = i; wid = j; dep = k; }
	T getVol() const { return (ht * wid * dep); }
};

template <typename X> ostream& operator<<(ostream& str, const ThreeD<X>& t) {
	str << "[";
	str << t.ht << ", " << t.wid << ", " << t.dep << "]";
	return str;
}
template <typename X> class my_compare_1 { //all "const"'s are needed
public:
	bool operator() (const ThreeD<X>& x1, const ThreeD<X>& x2) const {
		return (x1.getVol() < x2.getVol());
	}
};
template <typename X> class my_hash { //all "const"s are needed
public:
	size_t operator() (const ThreeD<X>& t)   const {
		hash<X> h;
		return h(t.ht + t.wid + t.dep);

	}
};
template <typename X> struct my_equal {
	bool operator()(const ThreeD<X>& t1, const ThreeD<X>& t2)  const {
		return (t1.getVol() == t2.getVol());
	}

};

int main() {




	unordered_map<int, string> M4 = { {6, "Dave"}, {8, "Sanjay"}, {4, "Nancy"},{3, "Ling"} };
	for (auto i : M4) { cout << i.first << " " << i.second; }
	cout << endl;

	ThreeD<int> t1(3, 4, 5), t2(1, 7, 8), t3(2, 3, 9);
	map<ThreeD<int>, int, my_compare_1<int> > M5 = { {t1, 1}, {t3, 3}, {t2,2} };
	for (auto i : M5) { cout << i.first << " " << i.second; }
	cout << endl;

	cout << "*****" << endl;
	unordered_map <ThreeD<int>, int, my_hash<int>, my_equal<int> > M6 = { {t1, 1}, {t3, 3}, {t2,2},{t1,4} };
	for (auto i : M6) { cout << i.first << " " << i.second; }
	cout << endl;
	cout << M6[t2] << endl;
	M6[t2] = 100;//will override

	cout << M6[t2] << endl;
	M6.insert({ t2,300 });
	cout << M6[t2] << endl;//will be ignored


	
	unordered_multimap<int, string> M7{ {3, "Dave"}, {2, "Steve"},{100, "John"}, {2, "Bob"} , {2, "Nancy"} };
	M7.insert({ 2, "John" });
	cout << "********" << endl;
	cout << (M7.find(2)->first) << M7.find(2)->second << endl;
	cout << "*********" << endl;


	auto ret = M7.equal_range(2); //function equal_range can apply to multimap, multiset, and
					  //unordered_multimap
	/*
	ret is a pair of iterators. {iterator1, iterator2}
	The two iterators set the range of all elements whose key is 2.
	Remember that iterator1 is the begining of the range, and iterator2 is the one past the
	last of the range.
	*/
	for_each(ret.first, ret.second, [](auto i) {cout << i.first << " " << i.second << " "; });
	//This for_each cannot be replaced with for.

	cout << endl;
	for (auto i : M7) { cout << i.first << " " << i.second << " "; }


	//Use default hash<string> and equal_to<string>
	string str1{ "C++ programming is not object-oriented." }, str2{ "Pointer operation is easy." },
		str3{ "Smart pointers can avoid memory leak." };
	unordered_map<string, string>M8{ {str3, "Yes!"}, { str1, "No!" }, { str2, "No!" } };
	cout << endl;
	cout << M8[str2] << endl;
	cout << M8.find(str2)->first << " " << M8.find(str2)->second << " " << endl;

	list<int> L10;
	for (auto i : { 4,5,6,7,8,9 }) { L10.push_back(i); }
	for (auto i : L10) { cout << i << " "; }
	cout << endl;
	stack<int> S10;
	for (auto i : { 1,2,3,4,5 }) { S10.push(i); }

	while (!S10.empty()) {
		cout << S10.top() << " ";
		S10.pop();
	}


	//unordered_multimap<vector<vector<int>>, my_Hash, my_Equal_to> DB;


	return 0;
}


/*
Output
6 Dave8 Sanjay4 Nancy3 Ling
[2, 3, 9] 3[1, 7, 8] 2[3, 4, 5] 1
*****
[3, 4, 5] 1[2, 3, 9] 3[1, 7, 8] 2
2
100
100
********
2Steve
*********
2 Steve 2 Bob 2 Nancy 2 John
3 Dave 2 Steve 2 Bob 2 Nancy 2 John 100 John
No!
Pointer operation is easy. No!
4 5 6 7 8 9
5 4 3 2 1
C:\Users\Roger\source\repos\Project290\Debug\Project290.exe (process 10624) exited with code 0.
Press any key to close this window . . .

*/

