//HW6 Due: March 8, Wednesday, at 11:59PM
#include <iostream>
#include <memory>
using namespace std;
template <typename T> class Node { //Your T has to support either int or float
public:
	shared_ptr<T> pValue; //pValue is a pointer to an object of type T
	shared_ptr<Node<T>> row_next;//Points to the next node in the same row
	shared_ptr<Node<T>> col_next;//Points to the nexe node in the same col
	Node() {}
	Node(T v) { pValue = make_shared<T>(v); }// pValue.reset(new T(v)); will also work,but slower
};

template <typename T> class Ring2D {
public:
	shared_ptr<Node<T>> head;//Points to the node at first row and first column
	Ring2D() {};

	//Implement the following functions:
	Ring2D(const initializer_list<T>& I); //initializer_list 
	/*
	the first two number in the initializer_list will be number of rows and number of columns
	followed by values in each row
	For example, for  3 4  1 2 3 4  5 6 7 8  9 10 11 12: 3 rows and 4 columns; first row: to 1 2 3 4;
	second row: 5 6 7 8; third row 9 10 11 12
	*/
	
	~Ring2D();//destructor; whenever possible, you should do minimum work.



	Ring2D(const Ring2D<T>& R);//copy constructor
	
	void operator=(const Ring2D<T>& R);//Lvalue operator=; copy assignment
	
	Ring2D(Ring2D<T>&& R);//move constructor
	void operator=(Ring2D<T>&& R);//Rvalue operator=; move assignment
	Ring2D<T> ThreeTimes();//Return a Ring2D with values being three times of the current Ring2D
	
	void DeleteRow(int r);//Delete row r of Ring2D
	//If r is out of range, simply do nothing and return.
	//void DeleteCol(int c);//Delete col c of Ring2D
	//If c is out of range, simply do nothing and return.
	
};


template <class T> void Ring2D<T>::DeleteRow(int r) {
	if (!head) return;
	int rr{ 1 }, cc{ 1 };
	shared_ptr<Node<T>> sp1 = head, sp2;
	while (sp1->row_next != head) { cc++; sp1 = sp1->row_next; }
	sp1 = head;
	while (sp1->col_next != head) { rr++; sp1 = sp1->col_next; }
	if (r<1 || r>rr) return;
	if (r == 1) { 
		if (rr == 1) {
			sp1 = head;
			for (int i = 0; i < cc; i++) {
				sp1->col_next.reset();
				sp1 = sp1->row_next;
			}
			head->row_next.reset();
			head.reset();
			return;
		}
		sp1 = head;
		sp2 = head->col_next;
		for (int i = 0; i < rr - 1; i++) { sp1 = sp1->col_next;}
		for (int i = 0; i < cc; i++) { 
			sp1->col_next = sp1->col_next->col_next;
			sp1 = sp1->row_next;
		}
		head->row_next.reset();
		head = sp2;
		return;
	}
	sp1 = head;
	while (r - 2 > 0) { sp1 = sp1->col_next; r--; }
	sp1->col_next->row_next.reset();
	for (int i = 0; i < cc; i++) {
		sp1->col_next = sp1->col_next->col_next;
		sp1 = sp1->row_next;
	}
}



template <class T> void Ring2D<T>::operator=(Ring2D<T>&& R) {//;//Rvalue operator=; move assignment
	if (head) {
		shared_ptr<Node<T>> sp11 = head;
		while (sp11->row_next != head) sp11 = sp11->row_next;
		shared_ptr<Node<T>> sp12 = sp11;
		sp12->row_next.reset();
		sp12 = sp12->col_next;
		while (sp12 != sp11) {
			sp12->row_next.reset();
			sp12 = sp12->col_next;
		}
		sp11 = head;
		while (sp11->col_next != head) sp11 = sp11->col_next;
		sp12 = sp11;
		sp12->col_next.reset();
		sp12 = sp12->row_next;
		while (sp12 != nullptr) {
			sp12->col_next.reset();
			sp12 = sp12->row_next;
		}

		head.reset();
	}
	head = R.head;
	R.head.reset();
	cout << "Move Assignment" << endl;
}

template<class T> Ring2D<T>::Ring2D(Ring2D<T>&& R) {//;//move constructor
	head = R.head;
	R.head.reset();
	cout << "Move Constructor" << endl;
}

template <class T> Ring2D<T> Ring2D<T>::ThreeTimes() {//ThreeTimes;
	auto temp{ *this };
	int r{ 1 }, c{ 1 };
	shared_ptr<Node<T>> sp1, sp2;
	sp1 = head;
	while (sp1->row_next != head) { c++; sp1 = sp1->row_next; }
	sp1 = head;
	while (sp1->col_next != head) { r++; sp1 = sp1->col_next; }

	sp1 = temp.head;
	for (int i = 0; i < r; i++) {
		sp2 = sp1->col_next;
		for (int j = 0; j < c; j++) {
			*sp1->pValue *= 3;
			sp1 = sp1->row_next;
		}
		sp1 = sp2;
	}
	return temp;
}



template <class T> Ring2D<T>::~Ring2D() {//;//destructor
	if (!head) { 
		cout << "Destructor" << endl;
		return;
	}
	shared_ptr<Node<T>> sp1 = head;
	while (sp1->row_next != head) sp1 = sp1->row_next;
	shared_ptr<Node<T>> sp2 = sp1;
	sp2->row_next.reset();
	sp2 = sp2->col_next;
	while (sp2 != sp1) {
		sp2->row_next.reset();
		sp2 = sp2->col_next;
	}

	sp1 = head;
	while (sp1->col_next != head) sp1 = sp1->col_next;
	sp2 = sp1;
	sp2->col_next.reset();
	sp2 = sp2->row_next;
	while (sp2 != nullptr) {
		sp2->col_next.reset();
		sp2 = sp2->row_next;
	}

	cout << "Destructor" << endl;
}


template <class T> void Ring2D<T>::operator=(const Ring2D<T>& R) {//;//Lvalue operator=; copy assignment
	if (head) {
		shared_ptr<Node<T>> sp11 = head;
		while (sp11->row_next != head) sp11 = sp11->row_next;
		shared_ptr<Node<T>> sp12 = sp11;
		sp12->row_next.reset();
		sp12 = sp12->col_next;
		while (sp12 != sp11) {
			sp12->row_next.reset();
			sp12 = sp12->col_next;
		}
		sp11 = head;
		while (sp11->col_next != head) sp11 = sp11->col_next;
		sp12 = sp11;
		sp12->col_next.reset();
		sp12 = sp12->row_next;
		while (sp12 != nullptr) {
			sp12->col_next.reset();
			sp12 = sp12->row_next;
		}

		head.reset();
	}
	if (!R.head) {
		cout << "Copy Assignment" << endl;
		return;
	}

	int r{ 1 }, c{ 1 };
	shared_ptr<Node<T>> sp0;
	sp0 = R.head;
	while (sp0->row_next != R.head) { c++; sp0 = sp0->row_next; }
	sp0 = R.head;
	while (sp0->col_next != R.head) { r++; sp0 = sp0->col_next; }
	sp0.reset();
	shared_ptr<Node<T>> sp1, sp2, sp3, pLast;
	for (int j = 0; j < c; j++) {
		sp2 = make_shared<Node<T>>();
		sp2->row_next = sp1;
		if (j == 0) pLast = sp2;
		sp1 = sp2;
	}
	pLast->row_next = sp1;
	head = sp1;

	sp0 = sp1;
	for (int i = 0; i < r - 1; i++) {
		sp1.reset();
		for (int j = 0; j < c; j++) {
			sp2 = make_shared<Node<T>>();
			sp2->row_next = sp1;
			if (j == 0) pLast = sp2;
			sp1 = sp2;
		}
		pLast->row_next = sp1;

		sp2 = sp0;
		sp3 = sp1;
		for (int j = 0; j < c; j++) {
			sp2->col_next = sp3;
			sp2 = sp2->row_next;
			sp3 = sp3->row_next;
		}
		sp0 = sp1;
	}
	sp2 = head;
	sp3 = sp0;
	for (int j = 0; j < c; j++) {
		sp3->col_next = sp2;
		sp2 = sp2->row_next;
		sp3 = sp3->row_next;
	}

	sp0 = head;
	sp1 = R.head;
	for (int i = 0; i < r; i++) {
		sp2 = sp0->col_next;
		sp3 = sp1->col_next;
		for (int j = 0; j < c; j++) {
			sp0->pValue = make_shared<T>(*sp1->pValue);
			sp0 = sp0->row_next;
			sp1 = sp1->row_next;
		}
		sp0 = sp2;
		sp1 = sp3;
	}
	cout << "Copy Assignment" << endl;
}


template<class T> Ring2D<T>::Ring2D(const Ring2D<T>& R) {//copy constructor
	if (!R.head) {
		cout << "Copy Constructor" << endl;
		return;
	}
	int r{ 1 }, c{ 1 };
	shared_ptr<Node<T>> sp0;
	sp0 = R.head;
	while (sp0->row_next != R.head) { c++; sp0 = sp0->row_next; }
	sp0 = R.head;
	while (sp0->col_next != R.head) { r++; sp0 = sp0->col_next; }
	sp0.reset();
	shared_ptr<Node<T>> sp1, sp2, sp3, pLast;
	for (int j = 0; j < c; j++) {
		sp2 = make_shared<Node<T>>();
		sp2->row_next = sp1;
		if (j == 0) pLast = sp2;
		sp1 = sp2;
	}
	pLast->row_next = sp1;
	head = sp1;

	sp0 = sp1;
	for (int i = 0; i < r - 1; i++) {
		sp1.reset();
		for (int j = 0; j < c; j++) {
			sp2 = make_shared<Node<T>>();
			sp2->row_next = sp1;
			if (j == 0) pLast = sp2;
			sp1 = sp2;
		}
		pLast->row_next = sp1;

		sp2 = sp0;
		sp3 = sp1;
		for (int j = 0; j < c; j++) {
			sp2->col_next = sp3;
			sp2 = sp2->row_next;
			sp3 = sp3->row_next;
		}
		sp0 = sp1;
	}
	sp2 = head;
	sp3 = sp0;
	for (int j = 0; j < c; j++) {
		sp3->col_next = sp2;
		sp2 = sp2->row_next;
		sp3 = sp3->row_next;
	}

	sp0 = head;
	sp1 = R.head;
	for (int i = 0; i < r; i++) {
		sp2 = sp0->col_next;
		sp3 = sp1->col_next;
		for (int j = 0; j < c; j++) {
			sp0->pValue = make_shared<T>(*sp1->pValue);
			sp0 = sp0->row_next;
			sp1 = sp1->row_next;
		}
		sp0 = sp2;
		sp1 = sp3;
	}
	cout << "Copy Constructor" << endl;
}

template <class T> Ring2D<T>::Ring2D(const initializer_list<T>& I) {
	auto p = I.begin();
	int r { *p };
	p++;
	int c { *p };
	p++;
	shared_ptr<Node<T>> sp0, sp1, sp2, sp3, pLast;
	for (int j = 0; j < c; j++) {
		sp2 = make_shared<Node<T>>();
		sp2->row_next = sp1;
		if (j == 0) pLast = sp2;
		sp1 = sp2;
	}
	pLast->row_next = sp1;
	head = sp1;

	sp0 = sp1;
	for (int i = 0; i < r - 1; i++) {
		sp1.reset();
		for (int j = 0; j < c; j++) {
			sp2 = make_shared<Node<T>>();
			sp2->row_next = sp1;
			if (j == 0) pLast = sp2;
			sp1 = sp2;
		}
		pLast->row_next = sp1;

		sp2 = sp0;
		sp3 = sp1;
		for (int j = 0; j < c; j++) {
			sp2->col_next = sp3;
			sp2 = sp2->row_next;
			sp3 = sp3->row_next;
		}
		sp0 = sp1;
	}
	sp2 = head;
	sp3 = sp0;
	for (int j = 0; j < c; j++) {
		sp3->col_next = sp2;
		sp2 = sp2->row_next;
		sp3 = sp3->row_next;
	}
	sp1 = head;
	for (int i = 0; i < r; i++) {
		sp2 = sp1->col_next;
		for (int j = 0; j < c; j++) {
			sp1->pValue = make_shared<T>(*p);
			p++;
			sp1 = sp1->row_next;
		}
		sp1 = sp2;
	}
	cout << "Initializer_list" << endl;
}


template<class T> ostream& operator<<(ostream& str, const Ring2D<T>& R) {
	if (!R.head) return str;
	int r{ 1 }, c{ 1 };
	shared_ptr<Node<T>> sp1, sp2;
	sp1 = R.head;
	while (sp1->row_next != R.head) { c++; sp1 = sp1->row_next; }
	sp1 = R.head;
	while (sp1->col_next != R.head) {r++; sp1 = sp1->col_next;}
	sp1 = R.head;
	for (int i = 0; i < r; i++) {
		sp2 = sp1->col_next;
		for (int j = 0; j < c; j++) {
			str << *sp1->pValue<<" ";
			sp1 = sp1->row_next;
		}
		sp1 = sp2;
		str << endl;
	}
	return str;
}



int main() {
	Ring2D<int> R1{ 3, 4,  1, 2, 3, 4,  5, 6, 7, 8,  9, 10, 11, 12 };//initializer_list
	cout << R1 << endl << endl;

	Ring2D<int> R2{ R1 };//copy constructor
	cout << R2 << endl << endl;
	
	Ring2D<int> R3;
	R3 = R1;//copy assignment
	cout << R3 << endl << endl;
	
	Ring2D<int> R4;
	R4 = R1.ThreeTimes();//this is pointing to object R1
	//Compiler will convert it to R4.operator=(R1.ThreeTimes());
	//copy constructor -- declare temp and initialize it to R1
	//move constructor -- create hidden (temporary) copy
	//destructor-- delete temp becuase it goes out of scope
	//move assignment -- Assign value from hidden copy to R4
	//destructor-- delete hedden copy because it goes out of scope
	cout << R4 << endl << endl;

	R4.DeleteRow(2); 
	cout << R4 << endl << endl;
	R4.DeleteRow(2);
	cout << R4 << endl << endl;
	R4.DeleteRow(1);
	cout << R4 << endl << endl;
	


	/*
	R4.DeleteCol(3);
	cout << R4 << endl << endl;
	*/
	return 0;
}






