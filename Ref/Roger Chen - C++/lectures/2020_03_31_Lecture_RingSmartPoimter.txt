#include <iostream>
#include <memory>
using namespace std;
template <typename T> class Node {
public:
	shared_ptr<T> pValue;
	shared_ptr<Node<T>> next;
	Node() {}
	Node(T v) { pValue = make_shared<T>(v); }// pValue.reset(new T(v));  slower
};

template <typename T> class Ring {
public:
	shared_ptr<Node<T>> head;
	//Node<T>* head;
	Ring() {};//Ring() = default;
	//Implement the following functions:
	Ring(const initializer_list<T>& I); //initializer_list
	~Ring();//destructor
	Ring(const Ring<T>& R);//copy constructor
	void operator=(const Ring<T>& R);//Lvalue operator=; copy assignment
	Ring(Ring<T>&& R);//move constructor
	void operator=(Ring<T>&& R);//Rvalue operator=; move assignment
	Ring<T> ThreeTimes();
};

template <class T> Ring<T>::Ring(const initializer_list<T>& I) { //initializer_list
	shared_ptr<Node<T>> p2;
	auto p = I.end() - 1;//const T * p = ...
	while (p != I.begin() - 1) {
		shared_ptr<Node<T>> p1 = make_shared<Node<T>>(*p);
		p1->next = head;
		head = p1;
		if (p == I.end() - 1) p2 = p1;//p2 will point to the last node of Ring
		p--;
	}
	p2->next = head;//form the ring
	cout << "Initializer_list" << endl;
}

template <class T> Ring<T>::~Ring() { //destructor
	if (!head) {
		cout << "Destrutor" << endl;
		return;
	}
	head->next.reset();
	cout << "Destrutor" << endl;
}


template <class T> Ring<T>::Ring(const Ring<T>& R) { //copy constructor
	shared_ptr<Node<T>> p1, p2, p3;
	if (!R.head) return;
	p1 = make_shared<Node<T>>();
	p1->next = head;
	head = p1;
	p3 = p1;
	p2 = R.head->next;
	while (p2 != R.head) {
		p1 = make_shared<Node<T>>();
		p1->next = head;
		head = p1;
		p2 = p2->next;
	}

	p1 = R.head;
	p2 = head;
	while (p2) {
		p2->pValue = make_shared<T>(*p1->pValue);
		p1 = p1->next;
		p2 = p2->next;
	}
	p3->next = head;
	cout << "Copy Constructor" << endl;
}

template <class T> void Ring<T>::operator=(const Ring<T>& R) { //Lvalue assignment, i.e., copy assignment
	if (head) {
		head->next.reset();
		head.reset();//wihtout this, the first node will not be deleted.
	}

	shared_ptr<Node<T>> p1, p2, p3;
	if (!R.head) return;
	p1 = make_shared<Node<T>>();
	p1->next = head;
	head = p1;
	p3 = p1;
	p2 = R.head->next;
	while (p2 != R.head) {
		p1 = make_shared<Node<T>>();
		p1->next = head;
		head = p1;
		p2 = p2->next;
	}
	//p2->next = head;
	p1 = R.head;
	p2 = head;
	while (p2) {
		p2->pValue = make_shared<T>(*p1->pValue);
		p1 = p1->next;
		p2 = p2->next;
	}
	p3->next = head;
	cout << "Copy Assignment" << endl;
}



template<class T> Ring<T>::Ring(Ring<T>&& R) { //Move constructor
	head = R.head;
	R.head.reset();
	cout << "Move Constructor" << endl;
}

template<class T> void Ring<T>::operator=(Ring<T>&& R) {//Rvalue assignment; move assignment
	if (head) {
		head->next.reset();
		head.reset();
	}
	head = R.head;
	R.head.reset();
	cout << "Move Assignment" << endl;
}

template<class T> Ring<T> Ring<T>::ThreeTimes() {
	Ring<T> temp = *this;// copy consturctor
	if (!head) return temp;
	shared_ptr<Node<T>> p1 = temp.head, p2;
	*(p1->pValue) *= 3;
	p2 = p1->next;
	while (p2 != temp.head) {
		*p2->pValue *= 3;
		p2 = p2->next;
	}
	return temp;//return move(temp); return by value;   move constructor
	//a temporary (or hidden) copy is created
	//destructor to remove temp

}


template <class T> ostream& operator<<(ostream& str, const Ring<T>& R) {
	if (!R.head) return str;
	str << *R.head->pValue << " ";
	shared_ptr<Node<T>> p1 = R.head->next;
	while (p1 != R.head) {
		str << *p1->pValue << " ";
		p1 = p1->next;
	}
	return str;
}

int main() {
	Ring<int> R1{ 10,20,30,40,50 };//initializer_list
	//cout << *R1.head->pValue << endl;
	cout << R1 << endl;

	Ring<int> R2{ R1 };//copy constructor
	cout << R2 << endl;

	Ring<int> R3;
	R3 = R1;//copy assignment
	cout << R3 << endl;

	Ring<int> R4;
	R4 = R1.ThreeTimes();//this is pointing to object R1
	//Compiler will convert it to R4.operator=(R1.ThreeTimes());
	//copy constructor -- declare temp and initialize it to R1
	//move constructor -- create hidden (temporary) copy
	//destructor-- delete temp becuase it goes out of scope
	//move assignment -- Assign value from hidden copy to R4
	//destructor-- delete hedden copy because it goes out of scope


	cout << R4 << endl;

	return 0;
}






